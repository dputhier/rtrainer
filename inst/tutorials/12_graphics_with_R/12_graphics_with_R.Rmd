---
# theme
# “bootstrap”, “cerulean”, “cosmo”, “darkly”, “flatly”, “journal”, “lumen”, “paper”, 
# “readable”, “sandstone”, “simplex”, “spacelab”, “united”, “yeti”
# highlight: `default`, `tango`, `pygments`, `kate`, `monochrome`, `espresso`, `zenburn`, 
# `haddock`, `breezedark`, `textmate`, `arrow`, or `rstudio` or a file with extension `.theme`.

title: "Graphiques basiques dans R"
output:
  learnr::tutorial:
    theme: default
    highlight: default
    fig_caption: yes
    self_contained: true
    toc: yes
    toc_float: 
      toc_collapsed: false
    toc_depth: 4
    number_sections: false
    progressive: true
  html_document:
    theme: cosmo
    fig_caption: yes
    self_contained: yes
    toc: yes
    toc_float: 
      toc_collapsed: false
    toc_depth: 3
    number_section: true
  beamer_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_tex: no
    slide_level: 2
    theme: Montpellier
    toc: yes
  ioslides_presentation:
    colortheme: dolphin
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    fonttheme: structurebold
    highlight: tango
    incremental: no
    keep_md: no
    slide_level: 2
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
  pdf_document:
    fig_caption: yes
    highlight: zenburn
    toc: yes
    toc_depth: 3
  slidy_presentation:
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    highlight: tango
    incremental: no
    keep_md: no
    self_contained: yes
    slide_level: 2
    smaller: yes
    theme: cerulean
    toc: yes
    widescreen: yes
font-import: http://fonts.googleapis.com/css?family=Risque
font-family: Garamond
transition: linear
runtime: shiny_prerendered
---

<!--  
Here the parameters about the documents.
https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf 
--> 


```{css, echo=FALSE}

```

<script language="JavaScript" type="text/javascript">
          
          function sizeTbl2(h,i) {
          var tbl = document.getElementById("section-" + i);
          tbl.style.display = h;
          }

</script>



<style>
.exo {
  border-radius: 5px;
  margin-top: 5px;
  margin-bottom: 5px;
  padding-top: 5px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  background-color: #fcede3;
  color: rgb(51, 51,153);
}
.tips {
       padding-top: 5px;
       padding-bottom: 5px;
       padding-left: 5px;
       padding-right: 5px;
       border: 1px dashed #2f6fab;
       background-color: #EEFFEE;
}
.solution {
            margin-top: 5px;
            margin-bottom: 5px;
            padding-top: 5px;
            padding-bottom: 5px;
            padding-left: 5px;
            padding-right: 5px;
            border: 1px dashed #FFFFFF;
            background-color: #EEEEFF;
            color: #0000BB;
            font-size: 11px;
}
</style>


```{r setup, include=FALSE}
library(learnr)
library(gradethis)
knitr::opts_chunk$set(echo=TRUE, eval=TRUE, cache=FALSE, message=FALSE, warning=FALSE, comment="")
gradethis::gradethis_setup()
```

## Introduction

Il y a au moins deux solutions pour créer des graphiques avec *R*. En utilisant la librairie **graphics** ou la librairie **ggplot2**. La deuxième solution est la plus récente et la plus aboutie du point de vue esthétique. Nous allons voir dans un premier temps la production de diagrammes avec la librairie **graphics**

## Les bases

### La fonction plot
Ici, nous présentons les choses à conna?tre pour créer un graphique dans R et modifier ses paramètres. 
La fonction de base est la fonction *plot* qui permet de réaliser un nuage de points. Ses arguments peuvent être, un vecteur (*vector*), deux vecteurs, une matrice (*matrix*) ou éventuellement un *data.frame*.

Construisons deux vecteurs $x$ et $y$ contenant 50 valeurs et représentons les simplement.\\

```{r plot_1, exercise=TRUE} 
set.seed(123)
x <- rnorm(50)
y <- x + rnorm(50, 10, 0.5)
plot(x, y)
```

### Titres, légendes et annotations

Les arguments de la fonction *plot* peuvent être connus en demandant de l'aide sur la fonction.

```{r plot_2, exercise=TRUE} 
help(plot) 
?plot      
```

L'argument *main* permet de donner un titre au graphique, *xlab* de nommer l'axe des abscisses et *ylab* l'axe des ordonnées.

```{r plot_3, exercise=TRUE, exercise.setup="plot_1" } 
plot(x, y, main="x et y", xlab="la variable x", ylab="la variable y")
```

Le rendu du graphique peut être modifié avec l'argument *type*.

<div class="exo">

- Etant donné le diagramme suivant, changé les valeur de type en:

- "n" (nothing)
- "p" (points)
- "l" (lines)
- "b" (both)
- "o" (both overlayed)
- "h" (histogram-like)
- "s" (steps)

```{r plot_4, exercise=TRUE, exercise.setup="plot_1" } 
plot(x, type="n")      # nothing
```

```{r plot_4-solution}
plot(x, type="n")      # nothing
plot(x, type="p")      # points,
plot(x, type="l")       # lines,
plot(x, type="b")      # both
plot(x, type="o")      # both overlayed,
plot(x, type="h")      # histogram-like
plot(x, type="s")      # steps
```
</div>
```{r eval=FALSE, echo=TRUE} 

```

Les arguments "xlim" et "ylim" définissent les valeurs minimales et maximales encadrant l'axe des x et des y.

```{r plot_5, exercise=TRUE, exercise.setup="plot_1" }
plot(x, y, main="x et y", xlab="la variable x", ylab="la variable y", ylim=c(-5,20))
```


La fonction *legend* permet d'ajouter une l<e9>gende au graphique.

```{r eval=FALSE, echo=TRUE}
plot(x, type="l", col="red", ylim=c(-5,20))
points(y, type="l", col="green")
legend("bottomleft", legend = c("x","y"), col = c("red", "green"), lty=1)
```

Par d<e9>faut, les axes sont repr<e9>sent<e9>s, cependant, on peut choisir de ne pas les repr<e9>senter et d'am<e9>liorer leur rendu avec la fonction *axis*.
```{r eval=FALSE, echo=TRUE}
plot(x,y,axes=FALSE)
axis(1,col="red",col.axis="blue",font.axis=3)
axis(2,col="red",col.axis="blue",font.axis=3)
```

L'argument *las* permet de contr<f4>ler le style des caract<e8>res le long des axes. Ses valeurs peuvent <ea>tre:
\begin{itemize}
 -  0: toujours parall<e8>les <e0> l'axe.
 -  1: toujours horizontaux.
 -  2: toujours perpendiculaires.
 -  3: toujours verticaux
\end{itemize}

```{r eval=FALSE, echo=TRUE}
plot(x,y, las=2)
```

Le type de points est contr?l? par l'argument "pch" ("point character"):

```{r eval=FALSE, echo=TRUE}
plot(1:5, 1:5, type="n", axes=F, xlab="", ylab="", xlim=c(1,6), ylim=c(1,6))
c <- 1
for(i in 1:5){
  for(j in 1:5){
    points(i,j,pch=c,cex=2)
    text(i,j,label=c, pos=3, off=3)
    c <- c+1
  }
}
```

La taille des points est contr<f4>l<e9> par l'argument *cex* ("character extension").

```{r eval=FALSE, echo=TRUE}
plot(x, y, cex=2)
```

## Couleurs
#### Gestion des couleurs
L'utilisateur dispose, par d?faut, de certaines couleurs dans sa ``palette''. Les couleurs disponibles peuvent ?tre
appell<e9>es avec avec la fonction *palette* (8 couleurs par d<e9>faut). 

```{r eval=FALSE, echo=TRUE}
palette()
```

Dans un graphique, les couleurs, souvent contr<f4>l<e9>es par l'argument \Rfunction{col}, peuvent <ea>tre d<e9>finies sous forme d'un vecteur d'entiers (ex:  *1:10*) ou d'un vecteur de cha<ee>nes de caract<e8>res. Dans le cas d'un vecteur d'entiers, ses valeurs permettront d'indexer le vecteur renvoy<e9> par la fonction palette. Ainsi, la valeur 1 correspondra <e0>  la premi<e8>re couleur de la palette et la valeur n <e0> la n\textsuperscript{i<e8>me} valeur de la palette (voir l'exemple qui suit). 
```{r eval=FALSE, echo=TRUE}
plot(1:8,1:8, col=1:8, pch =16, cex=5)
```

Dans le cas d'une cha<ee>ne de caract<e8>re on mettra des noms de couleurs (l'ensemble des noms possibles est renvoy<e9> par la fonction *colors*) ou des valeurs hexad<e9>cimales (du type \#CC00CC). 

```{r eval=FALSE, echo=TRUE}
colors()
mycolors <- sample(colors(), 8) # 8 couleurs choisies au hasard
plot(1:8,1:8, col= mycolors,  pch =16, cex=5)
```

Dans le cas de valeurs hexad?cimale, les  deux premiers caract?res correspondent au rouge, les deux suivants au vert et les deux derniers au bleu (ex: noir='000000', blanc='FFFFFF', rouge='FF00000'). Deux caract?res suppl?mentaires peuvent indiquer le degr? de transparence. \newline{} 
Des jeux de  couleurs au format hexad<e9>cimale peuvent <ea>tre renvoy<e9>s par des fonctions: *rainbow*, *heat.colors*, *topo.colors*, *cm.colors* et *terrain.colors* (...). Dans les commandes suivante l'argument *alpha* contr<f4>le la transparence.

```{r eval=FALSE, echo=TRUE}
heat.colors(length(x))
heat.colors(length(x), alpha=0.4)
mycolors <- heat.colors(length(x), alpha=0.7)
plot(sort(x), y[order(x)], col = mycolors, pch=16, cex=3)
```

Il existe par ailleurs un certains nombre de librairies permettant d'avoir acc?s ? d'autres palette de couleurs. Exemple, la librairie RColorBrewer. Etant donn? que les gammes de couleurs ne contiennent que 8 couleurs, le plus souvent, il est possible d'?tendre le jeu de couleurs avec la fonction colorRampPalette.

```{r eval=FALSE, echo=TRUE}
install.packages("RColorBrewer") # Dites "oui" si on vous demande quelque chose. 
library(RColorBrewer)
display.brewer.all()
mycolors <- brewer.pal( 8, "RdPu")
mycolors <- colorRampPalette(mycolors)(length(x))
plot(sort(x), y[order(x)], col = mycolors, pch=16, cex=3)
points(sort(x), y[order(x)], pch=1, cex=3)
```

## Fonctions graphiques secondaires
Ces fonctions graphiques secondaires permettent de modifier ou d'am<e9>liorer un graphique (*title*, *legend*, *arrows*, *points*, *lines*, *abline*, *grid* ...). 
\newline{} 
La fonction *abline* ajoute une ligne verticale ou horizontale au graphique. Le type de ligne est contr<f4>l<e9> par l'argument *lty* ("line type") qui peut prendre les valeurs: "blank", "solid", "dashed", "dotted", "dotdash", "longdash", ou "twodash" (un entier de 0 <e0> 6 peut <ea>tre utilis<e9>). La largeur de la ligne est contr<f4>l<e9>e par l'agument *lwd* ("line width"). La fonction *abline* permet aussi d'ajouter une droite de regression:

```{r eval=FALSE, echo=TRUE}
plot(sort(x), y[order(x)], col = mycolors, pch=16, cex=3)
abline(v=mean(x), lty="dashed", col="gray")
abline(h=mean(y), lty="dashed", col="gray")
abline(lm(y~x))
```

La fonction *grid* permet d'ajouter une grille au graphique:\\

```{r eval=FALSE, echo=TRUE}
plot(sort(x), y[order(x)], col = mycolors, pch=16, cex=3)
grid()
points(mean(x), mean(y), pch=16)
```

La fonction arrows permet d'ajouter une ou plusieurs fl?ches.\\

```{r eval=FALSE, echo=TRUE}
ind <- which(x  > 1)
plot(x,y, pch=16)
arrows(x[ind] -0.3, y[ind], x[ind], y[ind], length=0.1, lwd=2, col="gray")
```

La fonction *text* permet d'ajouter des cha<ee>nes de caract<e8>res <e0> certaines coordonn<e9>es du graphique:\\

```{r eval=FALSE, echo=TRUE}
pn <- 1:50
plot(x,y, pch=16)
text(x[ind], y[ind], pn[ind], pos=1, off=0.5, cex=0.7)
```

La fonction *identify* permet d'identifier des points sur le graphique:\\

```{r eval=FALSE, echo=TRUE}
plot(x,y, pch=16)
interestingPoints <- identify(x, y, label=pn)
```

La fonction *lines* a de multiples fonctions. Elle peut notamment permettre d'ajouter une r<e9>gression par fen<ea>tre du type *lowess*.\\

```{r eval=FALSE, echo=TRUE}
plot(x,y, pch=16)
lines(lowess(y~x), col="red", lwd=2)
```

## Autres graphiques
### Histogramme
La fonction *hist* permet de r<e9>aliser des histogrammes. Le nombre d'intervalles est contr<f4>l<e9> par l'argument *breaks*. Si on veut fixer les intervalles, on peut utiliser la fonction *seq*.
```{r eval=FALSE, echo=TRUE}
x1 <- rnorm(1000)
y1 <- rnorm(1000,2)
mycol <- rainbow(2, alpha=0.4)
hist(x1, col=mycol[1], border="white", xlim=c(-5,5))
hist(y1, col=mycol[2], border="white", add=TRUE)
x1y1 <- c(x1, y1)
br <- seq(from=min(x1y1), to= max(x1y1), length=50)
hist(x1y1,breaks=br, col=heat.colors(length(br)), border="white")
```

### Boites <e0> moustaches ("boxplot")

```{r eval=FALSE, echo=TRUE}
m <- cbind(x1,y1)
boxplot(m, pch=".", col=c("red", "green"))
```
% googleVis
% ggplot2
%rgl
### Diagrammes <e0> barres
```{r eval=FALSE, echo=TRUE}
col    <- c("palegreen","orangered")
col <- sort(rep(col, 10))
x <- runif(20,1,20)
x[1:10] <- x[1:10]^2
barplot(x, col=col,  border= col, names.arg = letters[1:20], beside=F, 
cex.axis=0.5, cex.names=0.5)
y <- x +rnorm(length(x), 5)
m <- rbind(x,y)
barplot(m, beside=T)
barplot(m, beside=F)
```

### Camemberts

```{r eval=FALSE, echo=TRUE}
example(pie)
```



## D'autres librairies tr<e8>s int<e9>ressantes
Il existe de tr<e8>s nombreuses librairies disponibles sur le site du CRAN. On peut citer parmi celles-ci les librairies: *diagram*, *rgl*, *ggplot2*, *lattice*, *googleVis*, ...\\
Quelques exemples:

```{r eval=FALSE, echo=TRUE}
install.packages("diagram")
library("diagram")
demo("flowchart")

install.packages("rgl")
library("rgl")
demo("rgl")

install.packages("googleVis")
library("googleVis")
demo("googleVis")
example(gvisMotionChart)
```